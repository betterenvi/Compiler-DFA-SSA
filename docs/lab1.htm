<html>
<head>
<title>Programming Assignment 1 -- CS 380C</title>
<base href="http://www.cs.utexas.edu/users/mckinley/380C/index.html">

<style type="text/css">
.style1 {
				font-family: Verdana, Arial, Helvetica, sans-serif;
				font-size: large;
				color: #330066;
}
.style2 {
				color: #FF0000;
}
</style>

</head>
<body>
<ul>
				<br>
				<hr>
				<p></p>
				<center class="style1">L<font size="5">ab 1: Write a 3-address-code to C translator</font></center><hr>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Objective </font></font></b></p>
				<p>The goal of this project is to write a translator from 3-address
	format to C. The purpose of this assignment is to</p>
				<ol>
								<li>Make you familiar with compiler intermediate formats, in this
		particular case, our 3-address format.</li>
								<li>Write a translator and test its correctness. You will also
		use this translator to test code transformations in future
		assignments.
		(This project is often the same one compiler writers will
		undertake when starting a new compiler, because it eases
		testing, assuming a correct C compiler.)
		</li>
								<li>Write example C code to test your translator.</li>
				</ol>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Project Description </font></font></b></p>
				<p>We provide 'csc', which compiles a subset of C (CS for C-Subset)
	to 3-address format. Your will write a translator to convert from this
	3-address format back to C. Note that the generated C code will not
	resemble the original C code.</p>
				<p>The rest of this document describes the c-subset compiler, the 3-address intermediate format, 
	the application binary interface (ABI), the implementation requirements, and the grading criteria.  
				</p>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Getting Started On Lab1 </font></font></b></p>
				<p></p>
				<ol>
								<li>Download the c-subset compiler and example C files at&nbsp;
								<a
			href="http://www.cs.utexas.edu/users/mckinley/380C/labs/cs380c_lab1.tgz">http://www.cs.utexas.edu/users/mckinley/380C/labs/cs380c_lab1.tgz</a></li>
								<li>Decompress the file on the cs unix machines using
								<pre>	&quot;tar xvfz cs380c_lab1.tgz&quot;.
</pre>
		This command will produce the following directory structure
								<pre>	cs380c_lab1
		src
		examples
		lab1
</pre>
		The src directory contains the C-subset compiler source file and a make
		script. The examples directory contains 10 example c files, and two
		bash scripts (check.sh, check-one.sh) for checking your lab1
		implementation (see 5 below).</li>
								<li>To compile the compiler
								<pre>	cd src; ./make.sh  // your shell should be bash
</pre>
		The command will produce a binary file for the compiler &quot;csc&quot;
		in the src directory.</li>
								<li>Compile the example c files by using &quot;csc&quot;
								<pre>	cd ../examples; ../src/csc loop.c;
</pre>
		This command will print out the 3-Address Intermediate Format code to your screen.</li>
								<li>Implement your own 3-Address to C converter in the lab1
		directory. Modify the script compile.sh to compile your source code if
		needed. Modify the script run.sh to invoke your translator.</li>
								<li>Verify your implementation. Modify the script
		examples/check-one.sh to set the variable THREE_ADDR_TO_C_TRANSLATOR
		(line5) to your own converter. Then invoke the command
		&quot;./check-one.sh loop.c&quot;. It produces several files:
								<pre>	loop.3addr     //the 3-address format file generated by csc
	loop.3addr.c   //the c file generated by your converter
	loop.3addr.bin //the binary file generated by gcc compiling loop.3addr.c
	loop.3addr.txt //the file after executing loop.3addr.bin
	loop.gcc.bin   //the binary file after gcc compiles loop.c
	loop.gcc.txt   //the file after executing loop.gcc.bin
</pre>
		If the two .txt files are same, it means your converter works correctly
		for this c file. The output message to your screen should be:
								<pre>	loop.c
	compiling loop.c
	loop.c: In function 'main':
	loop.c:10: warning: return type of 'main' is not 'int'
	4a39f3634793c530783afa3ff0b2bd7b  loop.gcc.txt
	4a39f3634793c530783afa3ff0b2bd7b  loop.3addr.txt
</pre>
								The last two lines show the md5sum results of the two .txt file. They
		should be same.</li>
								<li>Run your converter on all example files, including those you
		create (see Turning in your assignment below). The command
		&quot;check.sh&quot executes check-one.sh on every input example c
		file in the directory.</li>
								<li>Turn your implementation in. (Check &quot;Turning In Your
		Assignment&quot; section for more details.)</li>
				</ol>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Our High-Level Language (a subset of
	C) </font></font></b></p>
				<p>This section describes the high-level language C-subset language
	and the csc compiler. We first give a rough description, some examples,
	and then a formal description. The language includes:</p>
				<ul>
								<li>Arithmetic operations include +, -, *, /, %, &lt;, &lt;=, ==, !=,
		&gt;=, &gt;.</li>
								<li>One integer data type 'long' whose size is 8 bytes.</li>
								<li>Void datatype.</li>
								<li>Structs and arrays.</li>
								<li>Functions and recursion.</li>
								<li>Two namespaces/scopes -- global and local
		variables.</li>
								<li>Functions return void (i.e., nothing). The way to communicate
		the result of a function is to use global variables.
		(Not recommended otherwise :-)!)</li>
								<li>Parameters of functions can only be of type 'long'. You
		cannot pass structs, arrays, etc. as parameters.</li>
								<li>No pointers.</li>
								<li>No floating point.</li>
								<li>No gotos.</li>
								<li>The structured programming constructs:
		'if' and 'while'.</li>
								<li>The compiler supports only a single source file.</li>
				</ul>
				<p>Note: gcc must correctly compile the output C file of your
	translator. However, the C output itself is not restricted to C-subset.
	For example, you may use &quot;goto&quot; in your C output to simplify
	your implementation.</p>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">The 3-Address Intermediate Format </font>
				</font></b></p>
				<p>The csc compiler outputs 3-address format. Before taking a look
	at the specification of the 3-address format, let us look at a simple
	program and its corresponding representation.</p>
				<pre>	long global_array[24];
	
	struct Point {
	    long x;
	    long y;
	} p;
	
	void initialize_globals() {
	    long i;
	
	    i = 0;
	    while(i < 24) {
	        global_array[i] = i;
	    }
	
	    p.x = 13;
	    p.y = 7;
	}
	
	void simple_function(long a, long b) {
	    long local_array[3];
	
	    local_array[0] = a;
	    local_array[1] = b;
	    local_array[2] = a + b;
	
	    if (global_array[2] > a) {
	        global_array[3] = b + p.y;
	    }
	    p.x = local_array[a % 3];
	}
	
	instr 1: nop
	instr 2: enter 8
	instr 3: move 0 i#-8
	instr 4: cmplt i#-8 24
	instr 5: blbc (4) [11]
	instr 6: mul i#-8 8
	instr 7: add global_array_base#32576 GP
	instr 8: add (7) (6)
	instr 9: store i#-8 (8)
	instr 10: br [4]
	instr 11: add p_base#32560 GP
	instr 12: add (11) x_offset#0
	instr 13: store 13 (12)
	instr 14: add p_base#32560 GP
	instr 15: add (14) y_offset#8
	instr 16: store 7 (15)
	instr 17: ret 0
	
	instr 18: enter 24
	instr 19: mul 0 8
	instr 20: add local_array_base#-24 FP
	instr 21: add (20) (19)
	instr 22: store a#24 (21)
	instr 23: mul 1 8
	instr 24: add local_array_base#-24 FP
	instr 25: add (24) (23)
	instr 26: store b#16 (25)
	instr 27: mul 2 8
	instr 28: add local_array_base#-24 FP
	instr 29: add (28) (27)
	instr 30: add a#24 b#16
	instr 31: store (30) (29)
	instr 32: mul 2 8
	instr 33: add global_array_base#32576 GP
	instr 34: add (33) (32)
	instr 35: load (34)
	instr 36: cmple (35) a#24
	instr 37: blbs (36) [46]
	instr 38: mul 3 8
	instr 39: add global_array_base#32576 GP
	instr 40: add (39) (38)
	instr 41: add p_base#32560 GP
	instr 42: add (41) y_offset#8
	instr 43: load (42)
	instr 44: add b#16 (43)
	instr 45: store (44) (40)
	instr 46: add p_base#32560 GP
	instr 47: add (46) x_offset#0
	instr 48: mod a#24 3
	instr 49: mul (48) 8
	instr 50: add local_array_base#-24 FP
	instr 51: add (50) (49)
	instr 52: load (51)
	instr 53: store (52) (47)
	instr 54: ret 16
	instr 55: nop
</pre>
				<p>The 3-address format uses a simple RISC instruction set, and
	assumes an infinite number of virtual registers (we discuss the
	stack frame layout below in the Function ABI section).
	The operands to these
	instructions may be one of the following:</p>
				<ul>
								<li>GP (global pointer): A pointer to the beginning of the global
		address space.</li>
								<li>FP (frame pointer): A pointer to the beginning of the frame
		of the current function.</li>
								<li>Constants: For example, 24</li>
								<li>Address offsets:   In the name, <tt><b>global_array_base#32576</b></tt>, the
		number following the <tt><b>#</b></tt> is the
		starting address offset of variable <tt><b>global_array</b></tt> relative
		to the GP or FP.  The variable names before the <tt><b>#</b></tt> here and below are to help humans read the representation.
								</li>
								<li>Field offsets:  In <tt><b>y_offset#8</b></tt>, the 
		number following the <tt><b>#</b></tt> is the  
		starting address offset of field <tt><b>y</b></tt> relative
		to the starting address of the corresponding struct (<tt><b>p_base#32560</b></tt> in this example).</li>
								<li>Local variables (scalars): For example,
		<tt><b>a#24</b></tt> represents a local variable and
		its offset within the stack frame. You should ignore
		the offset for now (you will use it later for
		register allocation). You may assume that the variable
		<tt><b>a</b></tt> is allocated to the virtual register
		<tt><b>a</b></tt>.</li>
								<li>Register names: A <tt><b>(13)</b></tt> means virtual register 
								<tt><b>r13</b></tt>.
		Arithmetic and some other instructions write their results to a register. (See below for the complete list.) For example, instruction 
								<tt><b>13</b></tt> may write its result to <tt>
								<b>r13</b></tt>.
								<li>Instruction labels:  The  <tt><b>[46]</b></tt> label represents a instruction to jump to (in this
		example, jump to instruction 46).</li>
				</ul>
				<p>The instruction set contains the following instructions:</p>
				<ul>
								<li><b>Arithmetic instructions.</b> The opcodes
								<tt><b>add</b></tt>,
		<tt><b>sub</b></tt>, <tt><b>mul</b></tt>, <tt><b>div</b></tt>, <tt><b>mod</b></tt>,
								<tt><b>neg</b></tt>, <tt><b>cmpeq</b></tt>, <tt>
								<b>cmple</b></tt>, and
		<tt><b>cmplt</b></tt> perform arithmetic operations on their
		operand(s) and write the result to a virtual register. Instruction <tt>
								<b>k</b></tt>
		always writes its result to <tt><b>rk</b></tt>.  The meaning of the first six operands should be obvious.  The 
								<tt><b>cmpeq</b></tt> instruction
		tests equality, the <tt><b>cmple</b></tt> instruction tests less than or equal, and the 
								<tt><b>cmplt</b></tt> instruction tests less than. For example,
								<pre>	instr 42: add (41) y_offset#8
</pre>
								stands for: 
								<pre>	inter_42: r42 = r42 + 8
</pre>
								</li>
								<li>The opcode <tt><b>nop</b></tt> does nothing.
								<pre>	instr 1: nop
</pre>
								</li>
								<li><b>Branch instructions.</b> The opcodes are
								<tt><b>br</b></tt>,
		<tt><b>blbc</b></tt>, <tt><b>blbs</b></tt>, and <tt><b>call</b></tt>.
		The opcode <tt><b>br</b></tt> means unconditional branch. The opcodes
								<tt><b>blbc</b></tt> and <tt><b>blbs</b></tt> denote branch if the
		register is cleared (0) or set (1), respectively. The <tt><b>call</b></tt>
		is an unconditional &quot;jump and link&quot; instruction used for
		function calls. For example,
								<pre>	instr 37: blbs (36) [46]
</pre>
								means: 
								<pre>	instr_37: if (r36 != 0) goto instr_46;
</pre>
								</li>
								<li><b>Data movement instructions.</b> The <tt>
								<b>load</b></tt> and <tt><b>store</b></tt> instructions read
		from and write to memory. The <tt><b>move</b></tt> instruction copies virtual
		registers. For example,
								<pre>	instr 14: load (13)
	instr 15: move i#-8 j#-16
	instr 16: store (15) (11)
</pre>
		means:
								<pre>	instr_14: r14 = *(r13)
	instr_15: r15 = j = i
	instr_16: *(r11) = r15
</pre>
								</li>
								<li><b>I/O instructions.</b> The <tt><b>read</b></tt>, 
								<tt><b>write</b></tt>,
		and <tt><b>wrl</b></tt> are pseudo opcodes that are used for input and
		output. The <tt><b>read</b></tt> opcode reads a long integer from
		stdin, the <tt><b>write</b></tt> opcode prints a long integer to
		stdout, and <tt><b>wrl</b></tt> prints a newline to stdout.
								<pre>	instr 45: write x#-64
	instr 46: wrl
</pre>
								means: 
								<pre>	instr_45: WriteLong(x); //defined as printf(" %lld", x)
	instr_46: WriteLine();  //defined as printf("\n");
</pre>
								</li>
								<li>The <tt><b>param</b></tt> (used in conjunction with the call instruction)
		instruction pushes its operand onto the stack (it is used by a
		function that will be called in the future).
								<pre>	instr 60: param (59)
	instr 62: param from#40
	instr 63: call [23]
</pre>
		means:
								<pre>	instr_63: call function_23(r59, from);
</pre>
								</li>
								<li>The <tt><b>enter</b></tt> instruction denotes the beginning of a function.
		Its operand specifies the amount of memory in bytes to be allocated on
		the stack frame for local variables of that function.</li>
								<li>The <tt><b>ret</b></tt> instruction denotes a function return. Its operand
		specifies the amount of memory for formal parameters that needs to be
		removed (popped) from the stack. The following function
								<pre>	void function(long p1, long p2, long p3) {
		long x;
		long y;
	}
</pre>
		is compiled into
								<pre>	instr 1: nop
	instr 2: enter 16
	instr 3: ret 24
	instr 4: nop
</pre>
		which denotes 16 bytes of storage for local variables <tt><b>x</b></tt> and 
								<tt><b>y</b></tt> and then
		24 bytes for the formal parameters <tt><b>p1</b></tt>, <tt><b>p2</b></tt> and 
								<tt><b>p3</b></tt> that must be popped
		on a return.</li>
								<li>The <tt><b>entrypc</b></tt> instruction denotes the beginning of the 
								<tt><b>main</b></tt>
		function.
								<pre>	void main() {
		long i;
	}
</pre>
		is compiled into
								<pre>	instr 1: nop
	instr 2: entrypc
	instr 3: enter 8
	instr 4: ret 0
	instr 5: nop
</pre>
								</li>
				</ul>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Function Call ABI </font></font></b></p>
				<p>For our 3-address representation, we have used the following  
	Application Binary Interface (ABI), which specifies  
	the addresses/offsets for the global variables, local variables,
	and formal parameters.</p>
				<p>We layout structures and arrays out from lower to higher
	addresses. Since our only basic datatype occupies 8 bytes, all
	integers, structs and arrays are 8-byte aligned.</p>
				<p>We layout global variables starting at address 32768 and
	downwards towards zero. This organization implies that the maximum
	space for global variables is 32768. In your implementation, it would
	suffice to declare 32768 bytes of storage to hold all globals. In the
	above example, the global variables are <tt><b>global_array[24]</b></tt> and 
				<tt><b>p</b></tt>. Their
	starting addresses, represented as offsets from GP are</p>
				<pre>       global_array_base = 32576 = (32768 - (24*8)), and
       p_base            = 32560 = (32768 - (24*8) - 16),
</pre>
	respectively.

				<p>The stack grows from higher to lower addresses. The stack frame
	for a function looks like:</p>
				<pre>  Low        +---------------------+
  addr.      |                     |
             +---------------------+
   -32       |       ...           |
             +---------------------+ &lt;---+
   -24       |     3rd local       |     |
             +---------------------+     |
   -16       |     2nd local       |     |
             +---------------------+     |
   - 8       |     1st local       |     |
             +---------------------+     |   Stack
   FP ----&gt;  |        FP           |     |   frame
             +---------------------+     |
     8       |        LNK          |     |
             +---------------------+     |
    16       |     2nd param       |     |
             +---------------------+     |
    24       |     1st param       |     |
             +---------------------+ &lt;---+
             |                     |
             +---------------------+   previous frame.
  High       |                     |
  addr.      +---------------------+
</pre>
				<p>Accordingly, in the first example, <tt><b>local_array</b></tt>, and the formal
	parameters <tt><b>a</b></tt>, and <tt><b>b</b></tt>, have the following offsets from FP</p>
				<pre>     local_array_base: -24
     a:                 24
     b:                 16
</pre>
				<p>In your generated C code, you may use the same ABI, or you can define your own.
	For instance, you may choose to explicitly manage a stack
	to handle function calls, or use C's call-return mechanism to directly
	handle function calls in the 3-address code.
	</p>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">EBNF Grammar Specification </font></font></b>
				</p>
				<p>We provide a partial 
				<a href=http://en.wikipedia.org/wiki/Extended_Backus&#45;Naur_Form>EBNF grammar specification</a> to help you
	write C-subset programs and understand the 3-address format output
	generated by csc.</p>
				<p>The EBNF grammar for this language is given below.</p>
				<pre>    Factor = Designator | Number | &quot;(&quot; Expression &quot;)&quot;.
    Term = Factor {(&quot;*&quot; | &quot;/&quot; | &quot;%&quot;) Factor}.
    SimpleExpr = [&quot;+&quot; | &quot;-&quot;] Term {(&quot;+&quot; | &quot;-&quot;) Term}.
    EqualityExpr = SimpleExpr [(&quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;) SimpleExpr].
    Expression = EqualityExpr [(&quot;==&quot; | &quot;!=&quot;) EqualityExpr].
    ConstExpression = Expression.

    FieldList = VariableDeclaration {VariableDeclaration}.
    StructType = &quot;struct&quot; Ident [&quot;{&quot; FieldList &quot;}&quot;].
    Type = Ident | StructType.
    IdentArray = Ident {&quot;[&quot; ConstExpression &quot;]&quot;}.
    IdentList = IdentArray {&quot;,&quot; IdentArray}.
    VariableDeclaration = Type IdentList &quot;;&quot;.
    ConstantDeclaration = &quot;const&quot; Type Ident &quot;=&quot; ConstExpression &quot;;&quot;.

    Designator = Ident {(&quot;.&quot; Ident) | (&quot;[&quot; Expression &quot;]&quot;)}.
    Assignment = Designator &quot;=&quot; Expression &quot;;&quot;.
    ExpList = Expression {&quot;,&quot; Expression}.
    ProcedureCall = Ident &quot;(&quot; [ExpList] &quot;)&quot; &quot;;&quot;.
    IfStatement = &quot;if&quot; &quot;(&quot; Expression &quot;)&quot; &quot;{&quot; StatementSequence &quot;}&quot; 
                   [&quot;else&quot; &quot;{&quot; StatementSequence &quot;}&quot;].
    WhileStatement = &quot;while&quot; &quot;(&quot; Expression &quot;)&quot; &quot;{&quot; StatementSequence &quot;}&quot;.
    Statement = [Assignment | ProcedureCall | IfStatement | WhileStatement].
    StatementSequence = {Statement}.

    FPSection = Type IdentArray.
    FormalParameters = FPSection {&quot;,&quot; FPSection}.
    ProcedureHeading = Ident &quot;(&quot; [FormalParameters] &quot;)&quot;.
    ProcedureBody = {ConstDeclaration | VariableDeclaration} StatementSequence.
    ProcedureDeclaration = &quot;void&quot; ProcedureHeading &quot;{&quot; ProcedureBody &quot;}&quot;.

    Program = {ConstantDeclaration | VariableDeclaration} ProcedureDeclaration {ProcedureDeclaration}.
</pre>
	Number and Ident are terminal symbols. Program is the start symbol.
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Implementation and Turning in Your Assignment 
				</font></font></b></p>
				<p>You are free to implement your translator in the programming 
				language of your choice. The translator &quot;must&quot; compile (if 
				necessary) and run on regular linux machines.</p>
				<p>You should test your translator with the example programs we
	provide. In addition, please provide at least three non-trivial source
	programs for testing.</p>
				<p>Your assignment should contain the following.</p>
				<ol>
								<li>A single tgz file named lab1-group<span class="style2">X</span>.tgz 
								(X should be replaced by your group number), which, when extracted,
		creates directory lab1.</li>
								<li>The lab1 directory can contain sub-directories.</li>
								<li>The lab1 directory should contain the following files:</li>
								<ol type="a">
												<li>example1.c, example2.c, example3.c - Your non-trivial test
			programs. At the top of each file, explain what features this program
			tests.</li>
												<li>compile.sh - A script that compiles your source code, if
			needed. If you are using an interpreted language, this script can be
			empty.</li>
												<li>run.sh - A script that invokes your translator. Your
			translator should read 3-address code as input from stdin and print
			the generated C code to stdout. It should also generate a header file
			containing the declaration of all the functions. </li>
												<li>README - Please write your name(s) and 
												student ID(s) here. The lab1
			directory already exists with these files in the tarball you
			downloaded.</li>
								</ol>
				</ol>
				<p>Turn in your assignment by emailing the final lab1-groupX.tgz 
				to the instructor.</p>
				<pre>&nbsp;</pre>
				<p><b><font face="Verdana, Arial, Helvetica, sans-serif">
				<font
		size="4" color="#330066">Grading Rubric </font></font></b></p>
				<ol>
								<li>Correct translation of arithmetic operations (10 pts)</li>
								<li>Correct translation of branch instructions (10 pts)</li>
								<li>Correct translation of data transfer instructions
								<ol type="a">
												<li>Correct calculation of the addresses (7.5 pts)</li>
												<li>Correct translation of the move instruction (7.5 pts)</li>
												<li>Correct translation of the load instruction (7.5 pts)</li>
												<li>Correct translation of the store instruction (7.5 pts)</li>
								</ol>
								</li>
								<li>Correct translation of I/O instructions (5 pts)</li>
								<li>Correct translation of call and return semantics
								<ol type="a">
												<li>Correct parameter passing (10 pts)</li>
												<li>Correct stack clean up (10 pts)</li>
												<li>Correct stack frame management (15 pts)</li>
								</ol>
								</li>
								<li>Correct space allocation and access to the global and local
		variable (10 pts)</li>
				</ol>
				<p></p>
				<li>
				<p><b>
				<font size=4
color="#330066" face="Verdana, Arial, Helvetica, sans-serif">Acknowledgements
				</font></b>
				<p>These assignments are derived from
				<a href="http://www.cs.utexas.edu/users/mckinley/">Prof. Kathryn 
				McKinley</a>'s
				<a href="http://www.cs.utexas.edu/users/mckinley/380C/labs/labs.html">
				Advanced Compiler Techniques</a> class. </li>
</ul>

<p>

</body>
</html>
